= Notes from Clean Code by Robert C. Martin

== Meaningful Names

* The names of variables, functions, class should tell you *why* it exists, *what* is does and *why* is it used.
* It is not sufficient to add number series or noise words. If the names must be different they must mean something
different. eg. a1,a2 or if you have a _Product_ class and another _ProductInfo_ or _ProductData_ class, info and data
are noise.
* Use *_pronounceable_* names.
* Use *_searchable_* names.
* *_Class and objects_* should have *_noun or noun phrase_* like names. Avoid words like _manager_, _processor_, _data_, _info_
in class names.
* *_Method names_* should have *_verbs or verb phrase_* as name.
* Pick *_one word for one abstract concept_*. For eg. its confusing to have _fetch_, _retrieve_, _get_ as equivalent methods
of different class.
* If names aren't meaningful, you can add *_context_* around it, e.g _addrFirstName_ instead of firstName.

== Functions

* Functions should be as *_small_* as possible.
* Should *_not_* be large enough to *_hold nested structures_*, and hence *_indent level shouldn't be more than 1 or 2_*.
* It *_should do one thing_*. How to find if the function is doing one thing -
** It does only those steps that are one level below the stated name of the function.
** You shouldn't be able to extract another function that is not a replica or very similar to the implementation.
** One level of abstraction per function.
* *_The step down rule_* - All functions should be have smaller function which are at next level of abstraction, so you
are descending one level of abstraction at a time.
* When using *_switch statements_*, make sure they are buried deep down *_in a low level class_* and never repeated,
*_using polymorphism_*.
* Choose *_good names_* for *_smaller functions_* that do *_one thing_*. Don't be afraid to make long descriptive names.
* Function arguments :
** Ideal number of arguments = 1, at most 3.
** *Monadic functions*: Two very common reasons to pass single argument are -
*** Asking a question about the argument.
*** Transforming it into something else and returning it.
*** Used as an event, with function returning now return value. Instead it uses the argument to change the state of the system.
*** Flag arguments are bad. They mean that the function is doing more than one thing depending on the flag.
** *Dyadic functions* : 2 arguments. To be used when ordered components of a single value, natural cohesion and natural ordering.
* If you have *_side effects_* in the function, those must be *_mentioned in the name_* of the function.
* *_Output arguments_* should be avoided. If the function must change something, make it change the state of the onwing object.
* Command and query separation - A function should either do something or answer something. Not both.
* Prefer *_exception_* to returning *_error codes_*.
* Extract the *_body_* of *_try and catch_* into *_functions_* of their *_own_*.
* If *_try_* exists in a function, it should be the *_first word_* and *_nothing_* after *_catch/finally_*.
* *_Variables_* should be declared as *_close to the usage_* as possible.
* *_Control variables_* should be declared *_within the loop_* statement.
* *_Dependent function_* : If one function calls another they should be vertically close with *_caller above callee_*.
* *_Conceptual affinity_* : Functions should be close which are
** Calling one another.
** Using a variable.
** Group of functions performing similar function.

== Objects and Data structures

* Try _not_ to _expose details_ of your data, rather _express_ it  in _abstract terms_. Merely adding interface or/and
getters and setters is not good.
* *_Objects hide_* their *_data_* behind *_abstractions_* and *_expose functions_* that operate on that data. *_Data
structure expose_* their *_data_* and have *_no meaningful functions_*.
* *_Law of Demeter_* says that a *_method f_* of a *_class C _*should only call the methods of these:
** C
** An object created by f
** An object passed as an argument to f
** An object held in an instance variable of C
** The below code violates the law
[source, java]
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();

** However this code doesn't
[source, java]
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();

== Error handling

* Try to write tests that force exceptions, and then add behavior to your handler to satisfy your tests. This will
cause you to build the transaction scope of the try block first and will help you maintain the transaction nature of
that scope.
** Not a good code
[source, java]
public List<RecordedGrip> retrieveSection(String sectionName) {
try {
    FileInputStream stream = new FileInputStream(sectionName);
} catch (Exception e) {
    throw new StorageException("retrieval error", e);
}
return new ArrayList<RecordedGrip>();
}

** Good code
[source, java]
public List<RecordedGrip> retrieveSection(String sectionName) {
try {
    FileInputStream stream = new FileInputStream(sectionName);
    stream.close();
} catch (FileNotFoundException e) {
    throw new StorageException("retrieval error", e);
}
return new ArrayList<RecordedGrip>();
}

* *_Checked exceptions violate Open/Closed Principle_*. If you throw a checked exception from a method
in your code and the catch is three levels above, you must declare that exception in the signature of each method
between you and the catch. This means that a change at a low level of the software can force signature changes on many
higher levels. The changed modules must be rebuilt and redeployed, even though nothing they care about changed.

* Wrapping third-party APIs is a best practice. When you wrap a third-party API, you minimize your dependencies
upon it. You can choose to move to a different library in the future without much penalty.

* Wrapping also makes it easier to mock out third-party calls when you are testing your own code.
* With wrapping, you aren't tied to a particular vendorâ€™s API design choices. You can define an API that you feel
comfortable with.

** Dependency on external API
[source, java]
ACMEPort port = new ACMEPort(12);
try {
    port.open();
} catch (DeviceResponseException e) {
    reportPortError(e);
    logger.log("Device response exception", e);
} catch (ATM1212UnlockedException e) {
    reportPortError(e);
    logger.log("Unlock exception", e);
} catch (GMXError e) {
    reportPortError(e);
    logger.log("Device response exception");
} finally {
}

** Your choice
[source, java]
LocalPort port = new LocalPort(12);
try {
    port.open();
} catch (PortDeviceFailure e) {
    reportError(e);
    logger.log(e.getMessage(), e);
} finally {
...
}
public class LocalPort {
    private ACMEPort innerPort;
    public LocalPort(int portNumber) {
        innerPort = new ACMEPort(portNumber);
    }
    public void open() {
        try {
            innerPort.open();
        } catch (DeviceResponseException e) {
            throw new PortDeviceFailure(e);
        } catch (ATM1212UnlockedException e) {
            throw new PortDeviceFailure(e);
        } catch (GMXError e) {
            throw new PortDeviceFailure(e);
        }
    }
}

* Don't return *_null_* objects. f you are tempted to return null from a method, consider throwing an exception or
returning a SPECIAL CASE object instead.

* If you are calling a null-returning method from a third-party API, consider wrapping that method with a method that
either throws an exception or returns a special case object.

== Unit tests

* The tests and the production code are written together, with the tests just a few seconds ahead of the production code.

* Use the *_BUILD-OPERATE-CHECK_* pattern.

* Every test function in a JUnit test should have *_one and only one assert_* statement.

* Clean tests follow five other rules: *_F.I.R.S.T_*
** __F__ast - run fast
** __I__ndependent - not dependent on any other test
** __R__epeatable - repeatable in any environment.
** __S__elf validating - boolean output, they either pass or fail
** __T__imely - should be written just before the production code.

== Classes

* A class should begin with a list of variables.
** Public static constants, if any, should come first.
** Then private static variables,
** followed by private instance variables.
** Public functions should follow the list of variables.
** Put the private utilities called by a public function right after the public function itself.

* Have a *_concise name_* of the class. More ambiguous the name more likely that it has too many responsibilities.
Avoid names like _Processor_, _Manager_, _Super_ in the class.








